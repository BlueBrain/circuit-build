import datetime

CIRCUIT_DIR = '.'

BIONAME = os.path.realpath(os.path.expanduser(config.get('bioname', 'bioname')))

def bioname_path(filename):
    return os.path.join(BIONAME, filename)

# Load MANIFEST.yaml into workflow config
workflow.configfile(bioname_path('MANIFEST.yaml'))

BUILDER_RECIPE = bioname_path("builderRecipeAllPathways.xml")
MORPHDB = bioname_path("extNeuronDB.dat")

ATLAS = config['common']['atlas']
ATLAS_CACHE_DIR = ".atlas"

MORPH_RELEASE = config['common']['morph_release']
EMODEL_RELEASE = config['common']['emodel_release']

LOGS_DIR = "logs"

TOUCHES_DIR = "connectome/touches"
NRN_FUNCTIONAL_DIR = "connectome/functional"
NRN_STRUCTURAL_DIR = "connectome/structural"


SPACK_MODULEPATH = ":".join(
    '/gpfs/bbp.cscs.ch/apps/hpc/jenkins/modules/%s/2019-06/tcl/linux-rhel7-x86_64/' % component
    for component in [
        'applications',
        'external-libraries',
        'parallel-libraries',
        'serial-libraries',
        'tools',
    ]
)

NIX_MODULEPATH = '/nix/var/nix/profiles/per-user/modules/bb5-x86_64/modules-all/release/share/modulefiles/'

MODULES = {
    'brainbuilder':
        (SPACK_MODULEPATH, ['brainbuilder/0.11.3/python3']),
    'flatindexer':
        (NIX_MODULEPATH, ['nix/hpc/flatindexer/1.8.12']),
    'jinja2':
        (SPACK_MODULEPATH, ['python-dev/0.1/python3']),
    'parquet-converters':
        (SPACK_MODULEPATH, ['parquet-converters/0.4.1']),
    'placement-algorithm':
        (SPACK_MODULEPATH, ['placement-algorithm/2.0.8/python3']),
    'spykfunc':
        (SPACK_MODULEPATH, ['spykfunc/0.14.3/python3']),
    'synapsetool':
        (SPACK_MODULEPATH, ['synapsetool/0.4.1/parallel']),
    'touchdetector':
        (SPACK_MODULEPATH, ['touchdetector/5.1.0']),
}


def escape_single_quotes(value):
    return value.replace("'", "'\\''")


def log_path(name):
    timestamp = datetime.datetime.now().strftime("%Y%m%dT%H%M%S")
    return os.path.abspath(os.path.join(LOGS_DIR, "%s.%s.log" % (name, timestamp)))


def template_path(name):
    return os.path.join(workflow.basedir, 'templates', name)


def bbp_env(module_env, command, dump_log=False, slurm_env=None, skip_srun=False):
    result = " ".join(map(str, command))

    if (slurm_env is not None) and cluster_config:
        if slurm_env not in cluster_config:
            slurm_env = '__default__'
        slurm_config = cluster_config[slurm_env]
        result = "salloc -J {jobname} {alloc} {srun} sh -c '{cmd}'".format(
            jobname=slurm_config.get('jobname', 'cbuild'),
            alloc=slurm_config['salloc'],
            srun=('' if skip_srun else 'srun'),
            cmd=escape_single_quotes(result)
        )

    if module_env is not None:
        modulepath, modules = MODULES[module_env]
        result = "(" + " && ".join([
            "export MODULEPATH=%s" % modulepath,
            "module purge",
            "module load %s" % " ".join(modules),
            "echo MODULEPATH=%s" % modulepath,
            "module list",
            result,
        ]) + ")"

    if dump_log:
        result += " 2>&1 | tee {log}"

    return result


def spatial_index_files(prefix):
    return [
        "%s_%s" % (prefix, filename)
        for filename in [
            'index.dat',
            'index.idx',
            'payload.dat',
        ]
    ]


def connectome_files(nrn_dir, suffix=""):
    return [
        os.path.join(nrn_dir, filename + suffix)
        for filename in [
            'nrn.h5',
            'nrn_efferent.h5',
            'nrn_positions.h5',
            'nrn_positions_efferent.h5',
            'nrn_summary.h5',
        ]
    ]


rule default:
    input:
        'CircuitConfig_base',
        'circuit.mvd3',
        'start.target',


def build_circuit_config(nrn_path):
    return bbp_env(
        'jinja2',
        ["jinja2 --strict",
            "-D CIRCUIT_PATH=%s" % os.path.abspath(CIRCUIT_DIR),
            "-D NRN_PATH=%s" % os.path.abspath(nrn_path),
            "-D MORPH_PATH={MORPH_RELEASE}",
            "-D ME_TYPE_PATH=%s" % os.path.join(EMODEL_RELEASE, "hoc"),
            "-D ME_COMBO_INFO_PATH=%s" % os.path.join(EMODEL_RELEASE, "mecombo_emodel.tsv"),
            "-D BIONAME={BIONAME}",
            "-D ATLAS={ATLAS}",
            ("-D PROJECTIONS='%s'" % ";".join(config['projectionizer'])
                if 'projectionizer' in config else ""),
            template_path('CircuitConfig.j2'),
            "> {output}",
        ]
    )


rule circuitconfig_base:
    message:
        "Generate CircuitConfig w/o connectome"

    output:
        'CircuitConfig_base'

    shell:
        build_circuit_config(nrn_path='.')


rule circuitconfig_nrn:
    message:
        "Generate CircuitConfig for functional circuit (nrn.h5)"

    output:
        'CircuitConfig_nrn'

    shell:
        build_circuit_config(nrn_path=NRN_FUNCTIONAL_DIR)


rule circuitconfig_functional:
    message:
        "Generate CircuitConfig for functional circuit"

    output:
        'CircuitConfig'

    shell:
        build_circuit_config(nrn_path=(NRN_FUNCTIONAL_DIR + '/edges.sonata'))


rule circuitconfig_structural:
    message:
        "Generate CircuitConfig for structural circuit"

    output:
        'CircuitConfig_struct'

    shell:
        build_circuit_config(nrn_path=(NRN_STRUCTURAL_DIR + '/edges.sonata'))


rule place_cells:
    message:
        "Generate cell positions; assign me-types"

    output:
        'circuit.mvd3.somata'

    log:
        log_path('place_cells')

    shell:
        bbp_env(
            'brainbuilder',
            ["brainbuilder cells place",
                "--composition",
                    bioname_path("cell_composition.yaml"),
                "--mtype-taxonomy",
                    bioname_path("mtype_taxonomy.tsv"),
                "--atlas",
                    ATLAS,
                "--atlas-cache",
                    ATLAS_CACHE_DIR,
                ("--region " + config['common']['region']
                    if 'region' in config['common'] else ""),
                ("--mask " + config['common']['mask']
                    if 'mask' in config['common'] else ""),
                "--soma-placement",
                    config['place_cells']['soma_placement'],
                "--density-factor",
                    config['place_cells'].get('density_factor', 1.0),
            ] + [
                "--atlas-property %s %s" % item
                for item in config['place_cells'].get('atlas_property', {'region': '~brain_regions'}).items()
            ] + [
                ("--append-hemisphere"
                    if config['place_cells'].get('append_hemisphere', False) else ""),
                ("--sort-by " + ",".join(config['place_cells']['sort_by'])
                    if 'sort_by' in config['place_cells'] else ""),
                "--seed",
                    config['place_cells']['seed'],
                "--output",
                    "{output}",
            ],
            dump_log=True,
            slurm_env='place_cells'
        )


rule choose_morphologies:
    message:
        "Choose morphologies using 'placement hints' approach"

    input:
        'circuit.mvd3.somata'

    output:
        'morphologies.tsv'

    log:
        log_path('choose_morphologies')

    shell:
         bbp_env(
            'placement-algorithm',
            ["choose-morphologies",
                "--mvd3",
                    "{input}",
                "--atlas",
                    ATLAS,
                "--atlas-cache",
                    ATLAS_CACHE_DIR,
                "--morphdb",
                    MORPHDB,
                "--rules",
                    bioname_path("placement_rules.xml"),
                "--annotations",
                    os.path.join(MORPH_RELEASE, "annotations.json"),
                "--alpha",
                    config['choose_morphologies']['alpha'],
                "--seed",
                    config['choose_morphologies']['seed'],
                "--output",
                    "{output}",
            ],
            dump_log=True,
            slurm_env='choose_morphologies'
        )


rule assign_morphologies:
    message:
        "Assign morphologies"

    input:
        mvd3 = 'circuit.mvd3.somata',
        morph = 'morphologies.tsv'

    output:
        'circuit.mvd3.morphologies'

    log:
        log_path('assign_morphologies')

    shell:
         bbp_env(
            'placement-algorithm',
            ["assign-morphologies",
                "--mvd3",
                    "{input[mvd3]}",
                "--morph",
                    "{input[morph]}",
                "--atlas",
                    ATLAS,
                "--atlas-cache",
                    ATLAS_CACHE_DIR,
                "--max-drop-ratio",
                    config['assign_morphologies'].get('max_drop_ratio', 0.0),
                "--out-mvd3",
                    "{output}",
            ],
            dump_log=True
        )


rule assign_emodels:
    message:
        "Assign electrical models"

    input:
        'circuit.mvd3.morphologies'

    output:
        'circuit.mvd3'

    shell:
        bbp_env(
            'brainbuilder',
            ["brainbuilder cells assign-emodels",
                "--morphdb {MORPHDB}",
                "--output {output}",
                "{input}"
            ],
            slurm_env='assign_emodels'
        )


rule touchdetector:
    message:
        "Detect touches between neurites"

    input:
        mvd3 = 'circuit.mvd3',

    output:
        touch(TOUCHES_DIR + '/_SUCCESS')

    log:
        log_path('touchdetector')

    shell:
        bbp_env(
            'touchdetector',
            ["touchdetector",
                "--output",
                    "{TOUCHES_DIR}",
                "--touchspace=axodendritic",
                "--save-state",
                "{BUILDER_RECIPE}",
                "{input[mvd3]}",
                "{MORPH_RELEASE}/h5v1"
            ],
            dump_log=True,
            slurm_env='touchdetector'
        )


rule touch2parquet:
    message:
        "Convert touches to Parquet format"

    input:
        TOUCHES_DIR + '/_SUCCESS'

    output:
        TOUCHES_DIR + '/parquet/touchesData.0.parquet'

    shell:
        bbp_env(
            'parquet-converters',
            ["cd {TOUCHES_DIR}/parquet",
             "&&",
             "touch2parquetp ../touchesData.*"
            ],
            slurm_env='touch2parquet'
        )


def run_spykfunc(rule, nrn_dir):
    assert rule in ("spykfunc_s2s", "spykfunc_s2f", ), "Unknown rule calling run_spykfunc"

    filters = config.get(rule, {}).get("filters", [])
    assert " " not in filters, "Filters cannot have spaces"

    if filters:
        mode = "--filters %s" % ','.join(filters)

        # https://bbpteam.epfl.ch/project/issues/browse/FUNCZ-208?focusedCommentId=89736&page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-89736
        if rule == "spykfunc_s2s":
            for filter_rule in ("BoutonDistance", "SynapseProperties", ):
                assert filter_rule in filters, "s2s should have rule %s" % filter_rule
        elif rule == "spykfunc_s2f":
            for filter_rule in ("BoutonDistance",
                                "TouchRules",
                                "ReduceAndCut",
                                "SynapseProperties",
                                ):
                assert filter_rule in filters, "s2f should have rule %s" % filter_rule
    elif rule == "spykfunc_s2s":
        mode = "--s2s"
    elif rule == "spykfunc_s2f":
        mode = "--s2f"

    output_dir = os.path.join(nrn_dir, 'spykfunc')
    cmd = bbp_env(
        'spykfunc',
        ["env",
            "SPARK_USER=$(whoami)",
         "sm_run",
            cluster_config.get(rule, {}).get('sm_run', ""),
            "-w %s" % os.path.join(output_dir, '.sm_run'),
         "spykfunc",
            mode,
            "--output-order post",
            "--output-dir %s" % output_dir,
            "--spark-property spark.master=spark://$(srun sh -c '[ $SLURM_PROCID -eq 0 ] && hostname || true' | tail -n 1):7077",
        ] + [
            "--spark-property %s" % p
                for p in config.get(rule, {}).get('spark_property', [])
        ] + [
            BUILDER_RECIPE,
            os.path.abspath("{input[mvd3]}"),
            MORPH_RELEASE + '/h5v1/',
            os.path.abspath(TOUCHES_DIR + '/parquet/'),
        ],
        dump_log=True,
        slurm_env=rule,
        skip_srun=True
    )
    return cmd


rule spykfunc_s2s:
    message:
        "Convert touches into synapses (S2S)"

    input:
        mvd3 = 'circuit.mvd3',
        touches = TOUCHES_DIR + '/parquet/touchesData.0.parquet'

    output:
        NRN_STRUCTURAL_DIR + '/spykfunc/circuit.parquet/_SUCCESS'

    log:
        log_path('spykfunc_s2s')

    shell:
        run_spykfunc(
            'spykfunc_s2s',
            nrn_dir=NRN_STRUCTURAL_DIR
        )


rule spykfunc_s2f:
    message:
        "Prune touches and convert them into synapses (S2F)"

    input:
        mvd3 = 'circuit.mvd3',
        touches = TOUCHES_DIR + '/parquet/touchesData.0.parquet'

    output:
        NRN_FUNCTIONAL_DIR + '/spykfunc/circuit.parquet/_SUCCESS'

    log:
        log_path('spykfunc_s2f')

    shell:
        run_spykfunc(
            'spykfunc_s2f',
            nrn_dir=NRN_FUNCTIONAL_DIR
        )


rule parquet2syn2:
    message:
        "Convert synapses from Parquet to SYN2 format"

    input:
        '{nrn_dir}/spykfunc/circuit.parquet/_SUCCESS'

    output:
        '{nrn_dir}/circuit.syn2'

    log:
        log_path('parquet2syn2_{nrn_dir}')

    shell:
        bbp_env(
            'parquet-converters',
            ["parquet2syn2p",
                "-o {output}",
                "{wildcards.nrn_dir}/spykfunc/circuit.parquet/*.parquet",
            ],
            dump_log=True,
            slurm_env='parquet2syn2'
        )


rule targetgen_mvd3:
    message:
        "Generate start.target file"

    input:
        'circuit.mvd3'

    output:
        'start.target'

    shell:
        bbp_env(
            'brainbuilder',
            ["brainbuilder targets from-mvd3",
                ("--targets %s" % bioname_path(config['targetgen_mvd3']['targets'])
                    if 'targets' in config.get('targetgen_mvd3', {}) else ""),
                ("--allow-empty"
                    if config.get('targetgen_mvd3', {}).get('allow_empty', False) else ""),
                "--atlas",
                    ATLAS,
                "--atlas-cache",
                    ATLAS_CACHE_DIR,
                "--output {output}",
                "{input}"
            ],
            slurm_env='targetgen_mvd3'
        )


rule node_sets:
    message:
        "Generate SONATA node sets"

    input:
        'circuit.mvd3'

    output:
        'sonata/networks/nodes/All/node_sets.json'

    log:
        log_path('node_sets')

    shell:
        bbp_env(
            'brainbuilder',
            ["brainbuilder targets node-sets",
                ("--targets %s" % bioname_path(config['targetgen_mvd3']['targets'])
                    if 'targets' in config.get('targetgen_mvd3', {}) else ""),
                ("--allow-empty"
                    if config.get('targetgen_mvd3', {}).get('allow_empty', False) else ""),
                "--output {output}",
                "{input}"
            ],
            dump_log=True
        )


rule symlink_start_target:
    message:
        "Symlink start.target file from {wildcards.nrn_dir}"

    input:
        'start.target'

    output:
        '{nrn_dir}/start.target',

    shell:
        'cd {wildcards.nrn_dir} && ln -s ../../{input}'


rule spatial_index_segment:
    message:
        "Generate segment spatial index"

    input:
        'CircuitConfig_base',
        'circuit.mvd3',
        'start.target'

    output:
        spatial_index_files('SEGMENT')

    log:
        log_path('spatial_index_segment')

    shell:
        bbp_env(
            'flatindexer',
            [
             "SDKGenerator CircuitConfig_base segment All SEGMENT",
            ],
            dump_log=True,
            slurm_env='spatial_index_segment'
        )


rule spatial_index_synapse:
    message:
        "Generate synapse spatial index"

    input:
        'CircuitConfig_nrn',
        'circuit.mvd3',
        NRN_FUNCTIONAL_DIR + '/nrn.h5',
        NRN_FUNCTIONAL_DIR + '/start.target'

    output:
        spatial_index_files(NRN_FUNCTIONAL_DIR + '/SYNAPSE')

    log:
        log_path('spatial_index_synapse')

    shell:
        bbp_env(
            'flatindexer',
            [
             "cd {NRN_FUNCTIONAL_DIR} &&",
             "SDKGenerator ../../CircuitConfig_nrn synapse All SYNAPSE",
            ],
            dump_log=True,
            slurm_env='spatial_index_synapse'
        )


rule mvd3_to_sonata:
    message:
        "MVD3 -> SONATA Nodes"

    input:
        'circuit.mvd3'

    output:
        'sonata/networks/nodes/All/nodes.h5'

    shell:
        bbp_env(
            'brainbuilder',
            ["brainbuilder sonata from-mvd3",
                "--mecombo-info",
                    os.path.join(EMODEL_RELEASE, "mecombo_emodel.tsv"),
                "--population",
                    "All",
                "--output",
                    "{output}",
                "{input}"
            ],
            slurm_env='mvd3_to_sonata'
        )


rule syn2_to_sonata:
    message:
        "SYN2 -> SONATA Edges"

    input:
        'connectome/{nrn_dir}/circuit.syn2'

    output:
        'sonata/networks/edges/{nrn_dir}/All/edges.h5'

    shell:
        bbp_env(
            'brainbuilder',
            ["brainbuilder sonata from-syn2",
                "--population All",
                "--source All",
                "--target All",
                "--output {output}",
                "{input}"
            ],
            slurm_env='syn2_to_sonata'
        )


rule syn2_to_nrn:
    message:
        "SYN2 -> nrn.h5"

    input:
        'connectome/{nrn_dir}/circuit.syn2'

    output:
        'connectome/{nrn_dir}/nrn.h5'

    shell:
        bbp_env(
            'brainbuilder',
            ["brainbuilder nrn from-syn2",
                "--output connectome/{wildcards.nrn_dir}",
                "{input}"
            ],
            slurm_env='syn2_to_nrn'
        )


rule symlink_sonata_edges:
    message:
        "Symlink {wildcards.nrn_dir} SONATA edges"

    input:
        'sonata/networks/edges/{nrn_dir}/All/edges.h5'

    output:
        'connectome/{nrn_dir}/edges.sonata'

    shell:
        """
        cd connectome/{wildcards.nrn_dir}/ &&
        ln -s ../../sonata/networks/edges/{wildcards.nrn_dir}/All/edges.h5 edges.sonata
        """


rule subcellular:
    message:
        "Assign gene expressions / protein concentrations to cells"

    input:
        mvd3 = 'circuit.mvd3',
        directory = 'subcellular'

    output:
        'subcellular.h5'

    shell:
        bbp_env(
            'brainbuilder',
            ["brainbuilder subcellular assign",
                "{input[mvd3]}",
                "--subcellular-dir {input[directory]}",
                "--transcriptome {config[subcellular][transcriptome]}",
                "--mtype-taxonomy {config[subcellular][mtype_taxonomy]}",
                "--cell-proteins {config[subcellular][cell_proteins]}",
                "--synapse-proteins {config[subcellular][synapse_proteins]}",
                "--seed {config[subcellular][seed]}",
                "--output {output}"
            ],
            slurm_env='subcellular'
        )


def write_network_config(nrn_dir):
    return bbp_env(
        'brainbuilder',
        ["brainbuilder sonata network-config",
            "--base-dir",
                "'.'",
            "--morph-dir",
                "components/morphologies",
            "--emodel-dir",
                "components/biophysical_neuron_models",
            "--nodes-dir",
                "networks/nodes",
            "--nodes",
                "All",
            "--edges-dir",
                "networks/edges/%s" % nrn_dir,
            "--edges",
                "All",
            "-o {output}"
        ]
    )


rule circuitconfig_sonata:
    message:
        "Generate SONATA network config"

    output:
        'sonata/circuit_config.json'

    shell:
        write_network_config('functional')


rule circuitconfig_struct_sonata:
    message:
        "Generate SONATA network config (structural)"

    output:
        'sonata/struct_circuit_config.json'

    shell:
        write_network_config('structural')


rule functional:
    input:
        'CircuitConfig',
        'circuit.mvd3',
        'start.target',
        NRN_FUNCTIONAL_DIR + '/edges.sonata',


rule functional_all:
    input:
        rules.functional.input,
        rules.spatial_index_segment.output,
        rules.spatial_index_synapse.output,


rule functional_sonata:
    input:
        'sonata/circuit_config.json',
        'sonata/networks/nodes/All/nodes.h5',
        'sonata/networks/nodes/All/node_sets.json',
        'sonata/networks/edges/functional/All/edges.h5',


rule functional_nrn:
    input:
        'CircuitConfig_nrn',
        'circuit.mvd3',
        NRN_FUNCTIONAL_DIR + '/nrn.h5',
        NRN_FUNCTIONAL_DIR + '/start.target'


rule structural:
    input:
        'CircuitConfig_struct',
        'circuit.mvd3',
        'start.target',
        NRN_STRUCTURAL_DIR + '/edges.sonata',


rule structural_sonata:
    input:
        'sonata/struct_circuit_config.json',
        'sonata/networks/nodes/All/nodes.h5',
        'sonata/networks/nodes/All/node_sets.json',
        'sonata/networks/edges/structural/All/edges.h5',
