import datetime

CIRCUIT_DIR = '.'

BIONAME = os.path.realpath(config.get('bioname', 'bioname'))

def bioname_path(filename):
    return os.path.join(BIONAME, filename)

# Load MANIFEST.yaml into workflow config
workflow.configfile(bioname_path('MANIFEST.yaml'))

BUILDER_RECIPE = bioname_path("builderRecipeAllPathways.xml")
MORPHDB = bioname_path("extNeuronDB.dat")

ATLAS = config['common']['atlas']
ATLAS_CACHE_DIR = ".atlas"

MORPH_RELEASE = config['common']['morph_release']
EMODEL_RELEASE = config['common']['emodel_release']

LOGS_DIR = "logs"

TOUCHES_DIR = "connectome/touches"
NRN_FUNCTIONAL_DIR = "connectome/functional"
NRN_STRUCTURAL_DIR = "connectome/structural"


SPACK_MODULEPATH = ":".join(
    '/gpfs/bbp.cscs.ch/apps/hpc/jenkins/modules/%s/2019-03/tcl/linux-rhel7-x86_64/' % component
    for component in [
        'applications',
        'external-libraries',
        'parallel-libraries',
        'serial-libraries',
        'tools',
    ]
)

NIX_MODULEPATH = '/nix/var/nix/profiles/per-user/modules/bb5-x86_64/modules-all/release/share/modulefiles/'

MODULES = {
    'brainbuilder':
        (SPACK_MODULEPATH, ['brainbuilder/0.10.2/python3']),
    'flatindexer':
        (NIX_MODULEPATH, ['nix/hpc/flatindexer/1.8.12']),
    'functionalizer':
        (SPACK_MODULEPATH, ['functionalizer/3.11.0']),
    'jinja2':
        (SPACK_MODULEPATH, ['python-dev/0.1/python3']),
    'parquet-converters':
        (SPACK_MODULEPATH, ['parquet-converters/0.3']),
    'placement-algorithm':
        (SPACK_MODULEPATH, ['placement-algorithm/2.0.7/python3']),
    'spykfunc':
        (SPACK_MODULEPATH, ['spykfunc/0.13.0/python3']),
    'synapsetool':
        (SPACK_MODULEPATH, ['synapsetool/0.4.1/parallel']),
    'touchdetector':
        (SPACK_MODULEPATH, ['touchdetector/4.4.1']),
}


def enquote(value, quote="'"):
    return quote + value + quote


def escape_single_quotes(value):
    return value.replace("'", "'\\''")


def log_path(name):
    timestamp = datetime.datetime.now().strftime("%Y%m%dT%H%M%S")
    return os.path.abspath(os.path.join(LOGS_DIR, "%s.%s.log" % (name, timestamp)))


def template_path(name):
    return os.path.join(workflow.basedir, 'templates', name)


def bbp_env(module_env, command, dump_log=False, slurm_env=None, skip_srun=False):
    result = " ".join(map(str, command))

    if (slurm_env is not None) and cluster_config:
        if slurm_env not in cluster_config:
            slurm_env = '__default__'
        slurm_config = cluster_config[slurm_env]
        result = "salloc -J {jobname} {alloc} {srun} sh -c '{cmd}'".format(
            jobname=slurm_config.get('jobname', 'cbuild'),
            alloc=slurm_config['salloc'],
            srun=('' if skip_srun else 'srun'),
            cmd=escape_single_quotes(result)
        )

    if module_env is not None:
        modulepath, modules = MODULES[module_env]
        result = "(" + " && ".join([
            "export MODULEPATH=%s" % modulepath,
            "module purge",
            "module load %s" % " ".join(modules),
            "echo MODULEPATH=%s" % modulepath,
            "module list",
            result,
        ]) + ")"

    if dump_log:
        result += " 2>&1 | tee {log}"

    return result


def spatial_index_files(prefix):
    return [
        "%s_%s" % (prefix, filename)
        for filename in [
            'index.dat',
            'index.idx',
            'payload.dat',
        ]
    ]


def connectome_files(nrn_dir, suffix=""):
    return [
        os.path.join(nrn_dir, filename + suffix)
        for filename in [
            'nrn.h5',
            'nrn_efferent.h5',
            'nrn_positions.h5',
            'nrn_positions_efferent.h5',
            'nrn_summary.h5',
        ]
    ]


rule default:
    input:
        'CircuitConfig_base',
        'circuit.mvd3',
        'start.target',


def build_circuit_config(nrn_path):
    return bbp_env(
        'jinja2',
        ["jinja2 --strict",
            "-D CIRCUIT_PATH=%s" % os.path.abspath(CIRCUIT_DIR),
            "-D NRN_PATH=%s" % os.path.abspath(nrn_path),
            "-D MORPH_PATH={MORPH_RELEASE}",
            "-D ME_TYPE_PATH=%s" % os.path.join(EMODEL_RELEASE, "hoc"),
            "-D ME_COMBO_INFO_PATH=%s" % os.path.join(EMODEL_RELEASE, "mecombo_emodel.tsv"),
            "-D BIONAME={BIONAME}",
            "-D ATLAS={ATLAS}",
            ("-D PROJECTIONS='%s'" % ";".join(config['projectionizer'])
                if 'projectionizer' in config else ""),
            template_path('CircuitConfig.j2'),
            "> {output}",
        ]
    )


rule circuitconfig_base:
    message:
        "Generate CircuitConfig w/o connectome"

    output:
        'CircuitConfig_base'

    shell:
        build_circuit_config(nrn_path='.')


rule circuitconfig_functional:
    message:
        "Generate CircuitConfig for functional circuit"

    output:
        'CircuitConfig'

    shell:
        build_circuit_config(nrn_path=NRN_FUNCTIONAL_DIR)


rule circuitconfig_structural:
    message:
        "Generate CircuitConfig for structural circuit"

    output:
        'CircuitConfig_struct'

    shell:
        build_circuit_config(nrn_path=NRN_STRUCTURAL_DIR)


rule place_cells:
    message:
        "Generate cell positions; assign me-types"

    output:
        'circuit.mvd3.somata'

    log:
        log_path('place_cells')

    shell:
        bbp_env(
            'brainbuilder',
            ["brainbuilder cells place",
                "--composition",
                    bioname_path("cell_composition.yaml"),
                "--mtype-taxonomy",
                    bioname_path("mtype_taxonomy.tsv"),
                "--atlas",
                    ATLAS,
                "--atlas-cache",
                    ATLAS_CACHE_DIR,
                ("--region " + config['common']['region']
                    if 'region' in config['common'] else ""),
                ("--mask " + config['common']['mask']
                    if 'mask' in config['common'] else ""),
                "--soma-placement",
                    config['place_cells']['soma_placement'],
                "--density-factor",
                    config['place_cells'].get('density_factor', 1.0),
            ] + [
                "--atlas-property %s %s" % item
                for item in config['place_cells'].get('atlas_property', {'region': '~brain_regions'}).items()
            ] + [
                ("--append-hemisphere"
                    if config['place_cells'].get('append_hemisphere', False) else ""),
                ("--sort-by " + ",".join(config['place_cells']['sort_by'])
                    if 'sort_by' in config['place_cells'] else ""),
                "--seed",
                    config['place_cells']['seed'],
                "--output",
                    "{output}",
            ],
            dump_log=True,
            slurm_env='place_cells'
        )


rule choose_morphologies:
    message:
        "Choose morphologies using 'placement hints' approach"

    input:
        'circuit.mvd3.somata'

    output:
        'morphologies.tsv'

    log:
        log_path('choose_morphologies')

    shell:
         bbp_env(
            'placement-algorithm',
            ["choose-morphologies",
                "--mvd3",
                    "{input}",
                "--atlas",
                    ATLAS,
                "--atlas-cache",
                    ATLAS_CACHE_DIR,
                "--morphdb",
                    MORPHDB,
                "--rules",
                    bioname_path("placement_rules.xml"),
                "--annotations",
                    os.path.join(MORPH_RELEASE, "annotations.json"),
                "--alpha",
                    config['choose_morphologies']['alpha'],
                "--seed",
                    config['choose_morphologies']['seed'],
                "--output",
                    "{output}",
            ],
            dump_log=True,
            slurm_env='choose_morphologies'
        )


rule assign_morphologies:
    message:
        "Assign morphologies"

    input:
        mvd3 = 'circuit.mvd3.somata',
        morph = 'morphologies.tsv'

    output:
        'circuit.mvd3.morphologies'

    log:
        log_path('assign_morphologies')

    shell:
         bbp_env(
            'placement-algorithm',
            ["assign-morphologies",
                "--mvd3",
                    "{input[mvd3]}",
                "--morph",
                    "{input[morph]}",
                "--atlas",
                    ATLAS,
                "--atlas-cache",
                    ATLAS_CACHE_DIR,
                "--max-drop-ratio",
                    config['assign_morphologies'].get('max_drop_ratio', 0.0),
                "--out-mvd3",
                    "{output}",
            ],
            dump_log=True
        )


rule assign_emodels:
    message:
        "Assign electrical models"

    input:
        'circuit.mvd3.morphologies'

    output:
        'circuit.mvd3.emodels'

    shell:
        bbp_env(
            'brainbuilder',
            ["brainbuilder cells assign-emodels",
                "--morphdb {MORPHDB}",
                "--output {output}",
                "{input}"
            ],
            slurm_env='assign_emodels'
        )


rule set_circuit_seeds:
    message:
        "Set MVD3 /circuit/seeds"

    input:
        'circuit.mvd3.emodels'

    output:
        'circuit.mvd3'

    shell:
        bbp_env(
            'brainbuilder',
            ["brainbuilder mvd3 set-seeds",
                "--seeds",
                    ",".join(map(str, config['s2f']['seeds'])),
                "--output {output}",
                "{input}"
            ],
            slurm_env='set_circuit_seeds'
        )


rule mvd3_reorder_mtypes:
    message:
        "Re-order /library/mtypes to be aligned with builder recipe"

    input:
        'circuit.mvd3'

    output:
        'circuit.mvd3.reordered'

    shell:
        bbp_env(
            'brainbuilder',
            ["brainbuilder mvd3 reorder-mtypes",
                "--recipe",
                    BUILDER_RECIPE,
                "--output",
                    "{output}",
                "{input}"
            ],
            slurm_env='mvd3_reorder_mtypes'
        )


rule touchdetector:
    message:
        "Detect touches between neurites"

    input:
        'circuit.mvd3.reordered',

    output:
        touch(TOUCHES_DIR + '/_SUCCESS')

    log:
        log_path('touchdetector')

    shell:
        bbp_env(
            'touchdetector',
            ["env",
                "BGLOCKLESSMPIO_F_TYPE=0x47504653",
             "touchdetector",
                "--mvdFilePath={input}",
                "--morphologyPath={MORPH_RELEASE}/h5v1",
                "--recipePath={BUILDER_RECIPE}",
                "--enableSaveState",
                "--outputFolder={TOUCHES_DIR}",
            ],
            dump_log=True,
            slurm_env='touchdetector'
        )


def run_functionalizer(rule, output_dir, enable_pruning):
    return bbp_env(
        'functionalizer',
        ["env",
            "BGLOCKLESSMPIO_F_TYPE=0x47504653",
         "functionalizer",
            "--inMVD-file={input[mvd3]}",
            "--inDetector-file={TOUCHES_DIR}/touches",
            "--recipe-file={BUILDER_RECIPE}",
            "--database={MORPH_RELEASE}/h5v1",
            "--database-file={MORPHDB}",
            "--pruningType=%d" % (1 if enable_pruning else 0),
            "--disableDeltaOutput",
            "--outNCS-file=%s" % os.path.join(output_dir, "a.ncs"),
        ],
        dump_log=True,
        slurm_env=rule
    )


rule s2s:
    message:
        "Convert touches into synapses (S2S)"

    input:
        mvd3 = 'circuit.mvd3',
        touches = TOUCHES_DIR + '/_SUCCESS'

    output:
        connectome_files(NRN_STRUCTURAL_DIR, suffix=".0")

    log:
        log_path('s2s')

    shell:
        run_functionalizer(
            's2s',
            output_dir=NRN_STRUCTURAL_DIR,
            enable_pruning=False,
        )


rule s2f:
    message:
        "Prune touches and convert them into synapses (S2F)"

    input:
        mvd3 = 'circuit.mvd3',
        touches = TOUCHES_DIR + '/_SUCCESS'

    output:
        connectome_files(NRN_FUNCTIONAL_DIR, suffix=".0")

    log:
        log_path('s2f')

    shell:
        run_functionalizer(
            's2f',
            output_dir=NRN_FUNCTIONAL_DIR,
            enable_pruning=True,
        )


rule nrn_merge:
    input:
        'connectome/{nrn_dir}/{filename}.0'

    output:
        'connectome/{nrn_dir}/{filename}'

    wildcard_constraints:
        filename = ".*\.h5$"

    log:
        log_path('nrn_merge_{nrn_dir}_{filename}')

    shell:
        bbp_env(
            'brainbuilder',
            [
             "cd connectome/{wildcards.nrn_dir} &&",
             "brainbuilder nrn merge .",
                "--only {wildcards.filename}",
                "--link" if config.get('nrn_merge', "copy") == "link" else "",
            ],
            dump_log=True,
            slurm_env='nrn_merge'
        )


rule touch2parquet:
    message:
        "Convert touches to Parquet format"

    input:
        TOUCHES_DIR + '/_SUCCESS'

    output:
        TOUCHES_DIR + '/parquet/touchesData.0.parquet'

    shell:
        bbp_env(
            'parquet-converters',
            ["cd {TOUCHES_DIR}/parquet",
             "&&",
             "touch2parquetp ../touchesData.*"
            ],
            slurm_env='touch2parquet'
        )


def run_spykfunc(rule, nrn_dir, enable_pruning):
    output_dir = os.path.join(nrn_dir, 'spykfunc')
    return bbp_env(
        'spykfunc',
        ["env",
            "SPARK_USER=$(whoami)",
         "sm_run",
            cluster_config.get(rule, {}).get('sm_run', ""),
            "-w %s" % os.path.join(output_dir, '.sm_run'),
         "spykfunc",
            "--s2f" if enable_pruning else "--s2s",
            "--output-order post",
            "--output-dir %s" % output_dir,
            "--spark-property spark.master=spark://$(srun sh -c '[ $SLURM_PROCID -eq 0 ] && hostname || true' | tail -n 1):7077",
        ] + [
            "--spark-property %s" % p
                for p in config.get(rule, {}).get('spark_property', [])
        ] + [
            BUILDER_RECIPE,
            os.path.abspath("{input[mvd3]}"),
            MORPH_RELEASE + '/h5v1/',
            os.path.abspath(TOUCHES_DIR + '/parquet/'),
        ],
        dump_log=True,
        slurm_env=rule,
        skip_srun=True
    )


rule spykfunc_s2s:
    message:
        "Convert touches into synapses (S2S)"

    input:
        mvd3 = 'circuit.mvd3',
        touches = TOUCHES_DIR + '/parquet/touchesData.0.parquet'

    output:
        NRN_STRUCTURAL_DIR + '/spykfunc/circuit.parquet/_SUCCESS'

    log:
        log_path('spykfunc_s2s')

    shell:
        run_spykfunc(
            'spykfunc_s2s',
            nrn_dir=NRN_STRUCTURAL_DIR,
            enable_pruning=False,
        )


rule spykfunc_s2f:
    message:
        "Prune touches and convert them into synapses (S2F)"

    input:
        mvd3 = 'circuit.mvd3',
        touches = TOUCHES_DIR + '/parquet/touchesData.0.parquet'

    output:
        NRN_FUNCTIONAL_DIR + '/spykfunc/circuit.parquet/_SUCCESS'

    log:
        log_path('spykfunc_s2f')

    shell:
        run_spykfunc(
            'spykfunc_s2f',
            nrn_dir=NRN_FUNCTIONAL_DIR,
            enable_pruning=True
        )


rule parquet2syn2:
    message:
        "Convert synapses from Parquet to SYN2 format"

    input:
        '{nrn_dir}/spykfunc/circuit.parquet/_SUCCESS'

    output:
        '{nrn_dir}/circuit.syn2'

    log:
        log_path('parquet2syn2_{nrn_dir}')

    shell:
        bbp_env(
            'parquet-converters',
            ["parquet2syn2p",
                "-o {output}",
                "{wildcards.nrn_dir}/spykfunc/circuit.parquet/*.parquet",
            ],
            dump_log=True,
            slurm_env='parquet2syn2'
        )


rule targetgen_mvd3:
    message:
        "Generate start.target file"

    input:
        'circuit.mvd3'

    output:
        'start.target'

    shell:
        bbp_env(
            'brainbuilder',
            ["brainbuilder targets from-mvd3",
                ("--targets %s" % bioname_path(config['targetgen_mvd3']['targets'])
                    if 'targets' in config.get('targetgen_mvd3', {}) else ""),
                ("--allow-empty"
                    if config.get('targetgen_mvd3', {}).get('allow_empty', False) else ""),
                "--atlas",
                    ATLAS,
                "--atlas-cache",
                    ATLAS_CACHE_DIR,
                "--output {output}",
                "{input}"
            ],
            slurm_env='targetgen_mvd3'
        )


rule node_sets:
    message:
        "Generate SONATA node sets"

    input:
        'circuit.mvd3'

    output:
        'sonata/networks/All.node_sets.json'

    log:
        log_path('node_sets')

    shell:
        bbp_env(
            'brainbuilder',
            ["brainbuilder targets node-set",
                ("--targets %s" % bioname_path(config['targetgen_mvd3']['targets'])
                    if 'targets' in config.get('targetgen_mvd3', {}) else ""),
                ("--allow-empty"
                    if config.get('targetgen_mvd3', {}).get('allow_empty', False) else ""),
                "--output {output}",
                "{input}"
            ],
            dump_log=True
        )


rule symlink_start_target:
    message:
        "Symlink start.target file from {wildcards.nrn_dir}"

    input:
        'start.target'

    output:
        '{nrn_dir}/start.target',

    shell:
        'cd {wildcards.nrn_dir} && ln -s ../../{input}'


rule spatial_index_segment:
    message:
        "Generate segment spatial index"

    input:
        'CircuitConfig_base',
        'circuit.mvd3',
        'start.target'

    output:
        spatial_index_files('SEGMENT')

    log:
        log_path('spatial_index_segment')

    shell:
        bbp_env(
            'flatindexer',
            [
             "SDKGenerator CircuitConfig_base segment All SEGMENT",
            ],
            dump_log=True,
            slurm_env='spatial_index_segment'
        )


rule spatial_index_synapse:
    message:
        "Generate synapse spatial index"

    input:
        'CircuitConfig',
        'circuit.mvd3',
        NRN_FUNCTIONAL_DIR + '/start.target',
        connectome_files(NRN_FUNCTIONAL_DIR)

    output:
        spatial_index_files(NRN_FUNCTIONAL_DIR + '/SYNAPSE')

    log:
        log_path('spatial_index_synapse')

    shell:
        bbp_env(
            'flatindexer',
            [
             "cd {NRN_FUNCTIONAL_DIR} &&",
             "SDKGenerator ../../CircuitConfig synapse All SYNAPSE",
            ],
            dump_log=True,
            slurm_env='spatial_index_synapse'
        )


rule mvd3_to_sonata:
    message:
        "MVD3 -> SONATA Nodes"

    input:
        'circuit.mvd3'

    output:
        'sonata/networks/All.nodes.h5'

    shell:
        bbp_env(
            'brainbuilder',
            ["brainbuilder sonata from-mvd3",
                "--population All",
                "--output {output}",
                "{input}"
            ],
            slurm_env='mvd3_to_sonata'
        )


rule syn2_to_sonata:
    message:
        "SYN2 -> SONATA Edges"

    input:
        'connectome/{nrn_dir}/circuit.syn2'

    output:
        'sonata/networks/{nrn_dir}/All.edges.h5'

    shell:
        bbp_env(
            'brainbuilder',
            ["brainbuilder sonata from-syn2",
                "--population All",
                "--source All",
                "--target All",
                "--output {output}",
                "{input}"
            ],
            slurm_env='syn2_to_sonata'
        )


rule subcellular:
    message:
        "Assign gene expressions / protein concentrations to cells"

    input:
        mvd3 = 'circuit.mvd3',
        directory = 'subcellular'

    output:
        'subcellular.h5'

    shell:
        bbp_env(
            'brainbuilder',
            ["brainbuilder subcellular assign",
                "{input[mvd3]}",
                "--subcellular-dir {input[directory]}",
                "--transcriptome {config[subcellular][transcriptome]}",
                "--mtype-taxonomy {config[subcellular][mtype_taxonomy]}",
                "--cell-proteins {config[subcellular][cell_proteins]}",
                "--synapse-proteins {config[subcellular][synapse_proteins]}",
                "--seed {config[subcellular][seed]}",
                "--output {output}"
            ],
            slurm_env='subcellular'
        )


rule place_astrocytes:
    message:
        "Assign astrocyte soma positions & radii"

    output:
        'ngv/astrocytes.mvd3'

    log:
        log_path('place_astrocytes')

    shell:
        bbp_env(
            'brainbuilder',
            ["brainbuilder astrocytes place",
                "--atlas",
                    ATLAS,
                "--atlas-cache",
                    ATLAS_CACHE_DIR,
                "--density",
                    "{config[place_astrocytes][density]}",
                "--soma-radii",
                    enquote("{config[place_astrocytes][soma_radii]}"),
                "--seed",
                    "{config[place_astrocytes][seed]}",
                "--output",
                    "{output}",
            ],
            dump_log=True,
            slurm_env='place_astrocytes'
        )


rule astrocyte_domains_tesselate:
    message:
        "Tesselate astrocyte domains"

    input:
        'ngv/astrocytes.mvd3'

    output:
        'ngv/astrocyte_domains.h5'

    log:
        log_path('astrocyte_domains_tesselate')

    shell:
        bbp_env(
            'brainbuilder',
            ["brainbuilder astrocytes domains tesselate",
                "--atlas",
                    ATLAS,
                "--atlas-cache",
                    ATLAS_CACHE_DIR,
                "--output",
                    "{output}",
                "{input}",
            ],
            dump_log=True,
            slurm_env='astrocyte_domains_tesselate'
        )


rule astrocyte_domains_overlap:
    message:
        "Overlap astrocyte domains"

    input:
        'ngv/astrocyte_domains.h5'

    output:
        'ngv/astrocyte_domains_overlap.h5'

    log:
        log_path('astrocyte_domains_overlap')

    shell:
        bbp_env(
            'brainbuilder',
            ["brainbuilder astrocytes domains overlap",
                "--distr",
                    enquote("{config[astrocyte_domains_overlap][overlap]}"),
                "--seed",
                    "{config[astrocyte_domains_overlap][seed]}",
                "--output",
                    "{output}",
                "{input}",
            ],
            dump_log=True,
            slurm_env='astrocyte_domains_overlap'
        )


rule astrocyte_domains_mesh:
    message:
        "Mesh astrocyte domains"

    input:
        'ngv/{filename}.h5'

    output:
        'ngv/{filename}.stl'

    shell:
        bbp_env(
            'brainbuilder',
            ["brainbuilder astrocytes domains mesh",
                "--output",
                    "{output}",
                "{input}",
            ],
            slurm_env='astrocyte_domains_mesh'
        )


def write_network_config(nrn_dir):
    return bbp_env(
        'brainbuilder',
        ["brainbuilder sonata network-config",
            "--base-dir",
                'sonata',
            "--morph-dir",
                MORPH_RELEASE,
            "--nodes",
                "sonata/networks/All.nodes.h5",
            "--edges",
                "sonata/networks/{nrn_dir}/All.edges.h5".format(nrn_dir=nrn_dir),
            "-o {output}"
        ]
    )


rule circuitconfig_sonata:
    message:
        "Generate SONATA network config"

    output:
        'sonata/circuit_config.json'

    shell:
        write_network_config('functional')


rule circuitconfig_struct_sonata:
    message:
        "Generate SONATA network config (structural)"

    output:
        'sonata/struct_circuit_config.json'

    shell:
        write_network_config('structural')


rule functional_base:
    input:
        'CircuitConfig',
        'circuit.mvd3',
        NRN_FUNCTIONAL_DIR + '/start.target',


rule functional:
    input:
        rules.functional_base.input,
        connectome_files(NRN_FUNCTIONAL_DIR),


rule functional_syn2:
    input:
        rules.functional_base.input,
        NRN_FUNCTIONAL_DIR + '/circuit.syn2',


rule functional_sonata:
    input:
        'sonata/circuit_config.json',
        'sonata/networks/All.nodes.h5',
        'sonata/networks/All.node_sets.json',
        'sonata/networks/functional/All.edges.h5',


rule functional_all:
    input:
        rules.functional.input,
        rules.spatial_index_segment.output,
        rules.spatial_index_synapse.output,


rule structural_base:
    input:
        'CircuitConfig_struct',
        'circuit.mvd3',
        NRN_STRUCTURAL_DIR + '/start.target',


rule structural:
    input:
        rules.structural_base.input,
        connectome_files(NRN_STRUCTURAL_DIR),


rule structural_syn2:
    input:
        rules.structural_base.input,
        NRN_STRUCTURAL_DIR + '/circuit.syn2',


rule structural_sonata:
    input:
        'sonata/struct_circuit_config.json',
        'sonata/networks/All.nodes.h5',
        'sonata/networks/All.node_sets.json',
        'sonata/networks/structural/All.edges.h5',


rule ngv:
    input:
        'ngv/astrocytes.mvd3',
        'ngv/astrocyte_domains.h5',
        'ngv/astrocyte_domains.stl',
        'ngv/astrocyte_domains_overlap.h5',
        'ngv/astrocyte_domains_overlap.stl',
