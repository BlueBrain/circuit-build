import datetime

CIRCUIT_DIR = '.'

BIONAME = os.path.realpath(config.get('bioname', 'bioname'))

def bioname_path(filename):
    return os.path.join(BIONAME, filename)

# Load MANIFEST.yaml into workflow config
workflow.configfile(bioname_path('MANIFEST.yaml'))

BUILDER_RECIPE = bioname_path("builderRecipeAllPathways.xml")
MORPHDB = bioname_path("extNeuronDB.dat")

ATLAS = config['common']['atlas']
ATLAS_CACHE_DIR = ".atlas"

MORPH_RELEASE = config['common']['morph_release']
EMODEL_RELEASE = config['common']['emodel_release']

NRN_FILES = [
    'nrn.h5',
    'nrn_efferent.h5',
    'nrn_positions.h5',
    'nrn_positions_efferent.h5',
    'nrn_summary.h5',
]

INDEX_FILES = [
    '_index.dat',
    '_index.idx',
    '_payload.dat',
]

LOGS_DIR = "logs"

SEGMENT_INDEX = expand('SEGMENT{filename}', filename=INDEX_FILES)

TOUCHES_DIR = "connectome/touches"

NRN_FUNCTIONAL_DIR = "connectome/functional"
NRN_FUNCTIONAL_DATA = expand(NRN_FUNCTIONAL_DIR + '/{filename}', filename=NRN_FILES)
NRN_FUNCTIONAL_INDEX = expand(NRN_FUNCTIONAL_DIR + '/SYNAPSE{filename}', filename=INDEX_FILES)

NRN_STRUCTURAL_DIR = "connectome/structural"
NRN_STRUCTURAL_DATA = expand(NRN_STRUCTURAL_DIR + '/{filename}', filename=NRN_FILES)

PRE_FUNCTIONAL = [
    'CircuitConfig',
    'circuit.mvd3',
    NRN_FUNCTIONAL_DIR + '/start.target',
]


def enquote(value, quote="'"):
    return quote + value + quote


def escape_single_quotes(value):
    return value.replace("'", "'\\''")


def log_path(name):
    timestamp = datetime.datetime.now().strftime("%Y%m%dT%H%M%S")
    return os.path.abspath(os.path.join(LOGS_DIR, "%s.%s.log" % (name, timestamp)))


def template_path(name):
    return os.path.join(workflow.basedir, 'templates', name + ".j2")


def bbp_env(modules, command, dump_log=False, slurm_env=None, skip_srun=False):
    full_cmd = []

    sw_release = config['common']['sw_release']
    if sw_release is None:
        full_cmd.append(
            "export MODULEPATH=${{MODULEPATH}}:/gpfs/bbp.cscs.ch/apps/hpc/jenkins/deploy/applications/2018-12-19/modules/tcl/linux-rhel7-x86_64"
        )
    else:
        full_cmd.append(
            "export MODULEPATH=/gpfs/bbp.cscs.ch/apps/hpc/spack-deployments/{sw_release}/modules/tcl/linux-rhel7-x86_64".format(
                sw_release=sw_release
            )
        )

    if modules:
        full_cmd.extend([
            "module purge",
            "module load " + " ".join(modules),
        ])

    full_cmd.append(" ".join(map(str, command)))

    result = " && ".join(full_cmd)

    if (slurm_env is not None) and cluster_config:
        if slurm_env not in cluster_config:
            slurm_env = '__default__'
        slurm_config = cluster_config[slurm_env]
        result = "salloc -J {jobname} {alloc} {srun} sh -c '{cmd}'".format(
            jobname=slurm_config.get('jobname', 'cbuild'),
            alloc=slurm_config['salloc'],
            srun=('' if skip_srun else 'srun'),
            cmd=escape_single_quotes(result)
        )

    if dump_log:
        result += " 2>&1 | tee {log}"

    return result


localrules:
    all,
    functional,
    functional_all,
    structural,
    circuitconfig,
    circuitconfig_struct,
    symlink_start_target,
    ngv


rule all:
    input:
        PRE_FUNCTIONAL


rule functional:
    input:
        PRE_FUNCTIONAL,
        NRN_FUNCTIONAL_DATA,


rule functional_syn2:
    input:
        PRE_FUNCTIONAL,
        NRN_FUNCTIONAL_DIR + '/circuit.syn2',


rule functional_sonata:
    input:
        PRE_FUNCTIONAL,
        'nodes.sonata',
        NRN_FUNCTIONAL_DIR + '/edges.sonata',


rule functional_all:
    input:
        PRE_FUNCTIONAL,
        NRN_FUNCTIONAL_DATA,
        NRN_FUNCTIONAL_INDEX,
        SEGMENT_INDEX,


rule structural:
    input:
        'CircuitConfig_struct',
        'circuit.mvd3',
        NRN_STRUCTURAL_DIR + '/start.target',
        NRN_STRUCTURAL_DATA,


rule structural_syn2:
    input:
        'CircuitConfig_struct',
        'circuit.mvd3',
        NRN_STRUCTURAL_DIR + '/start.target',
        NRN_STRUCTURAL_DIR + '/circuit.syn2',


def build_circuit_config(nrn_path):
    return bbp_env(
        ['nix/py27/jinja2'],
        ["jinja2 --strict",
            "-D CIRCUIT_PATH=%s" % os.path.abspath(CIRCUIT_DIR),
            "-D NRN_PATH=%s" % os.path.abspath(nrn_path),
            "-D MORPH_PATH={MORPH_RELEASE}",
            "-D ME_TYPE_PATH=%s" % os.path.join(EMODEL_RELEASE, "hoc"),
            "-D ME_COMBO_INFO_PATH=%s" % os.path.join(EMODEL_RELEASE, "mecombo_emodel.tsv"),
            "-D BIONAME={BIONAME}",
            "-D ATLAS={ATLAS}",
            ("-D PROJECTIONS=%s" % ":".join(config['projectionizer'])
                if 'projectionizer' in config else ""),
            template_path('CircuitConfig'),
            "> {output}",
        ]
    )

rule circuitconfig:
    message:
        "Generate CircuitConfig"

    output:
        'CircuitConfig'

    shell:
        build_circuit_config(nrn_path=NRN_FUNCTIONAL_DIR)


rule circuitconfig_struct:
    message:
        "Generate CircuitConfig_struct"

    output:
        'CircuitConfig_struct'

    shell:
        build_circuit_config(nrn_path=NRN_STRUCTURAL_DIR)


rule place_cells:
    message:
        "Generate cell positions; assign me-types"

    output:
        'circuit.mvd3.metypes'

    log:
        log_path('place_cells')

    shell:
        bbp_env(
            ['brainbuilder'],
            ["brainbuilder cells create2",
                "--composition",
                    bioname_path("cell_composition.yaml"),
                "--mtype-taxonomy",
                    bioname_path("mtype_taxonomy.tsv"),
                "--atlas",
                    ATLAS,
                "--atlas-cache",
                    ATLAS_CACHE_DIR,
                ("--region " + config['common']['region']
                    if 'region' in config['common'] else ""),
                "--soma-placement",
                    config['place_cells']['soma_placement'],
                "--density-factor",
                    config['place_cells'].get('density_factor', 1.0),
                "--seed",
                    config['place_cells']['seed'],
                "--output",
                    "{output}",
            ],
            dump_log=True,
            slurm_env='place_cells'
        )


rule assign_morphologies:
    message:
        "Assign morphologies using 'placement hints' approach"

    input:
        'circuit.mvd3.metypes'

    output:
        'circuit.mvd3.morphologies'

    log:
        log_path('assign_morphologies')

    shell:
        bbp_env(
            ['nix/nse/placement-algorithm'],
            ["env",
                "PATH=$PATH:/nfs4/bbp.epfl.ch/sw/tools/spark/2.2.0/bin",
                "JAVA_HOME=/nfs4/bbp.epfl.ch/sw/tools/java/1.8u51",
                "SPARK_LOCAL_DIRS=$TMPDIR",
                "SPARK_CONF_DIR=" + bioname_path("spark/assign_morphologies"),
             "assign-morphologies",
                "--mvd3 {input}",
                "--atlas {ATLAS}",
                "--atlas-cache {ATLAS_CACHE_DIR}",
                "--resolution {config[assign_morphologies][resolution]}",
                "--morphdb {MORPHDB}",
                "--annotations",
                    os.path.join(MORPH_RELEASE, "annotations"),
                "--rules",
                    bioname_path("placement_rules.xml"),
                "--alpha {config[assign_morphologies][alpha]}",
                "--seed {config[assign_morphologies][seed]}",
                "--ntasks {config[assign_morphologies][ntasks]}",
                "--output {output}",
            ],
            dump_log=True,
            slurm_env='assign_morphologies'
        )


rule assign_emodels:
    message:
        "Assign electrical models"

    input:
        'circuit.mvd3.morphologies'

    output:
        'circuit.mvd3.emodels'

    shell:
        bbp_env(
            ['brainbuilder'],
            ["brainbuilder cells assign-emodels",
                "--morphdb {MORPHDB}",
                "--output {output}",
                "{input}"
            ],
            slurm_env='assign_emodels'
        )


rule set_circuit_seeds:
    message:
        "Set MVD3 /circuit/seeds"

    input:
        'circuit.mvd3.emodels'

    output:
        'circuit.mvd3'

    shell:
        bbp_env(
            ['brainbuilder'],
            ["brainbuilder mvd3 set-seeds",
                "--seeds",
                    ",".join(map(str, config['s2f']['seeds'])),
                "--output {output}",
                "{input}"
            ],
            slurm_env='set_circuit_seeds'
        )


rule mvd3_reorder_mtypes:
    message:
        "Re-order /library/mtypes to be aligned with builder recipe"

    input:
        'circuit.mvd3'

    output:
        'circuit.mvd3.reordered'

    shell:
        bbp_env(
            ['brainbuilder'],
            ["brainbuilder mvd3 reorder-mtypes",
                "--recipe {BUILDER_RECIPE}",
                "--output {output}",
                "{input}"
            ],
            slurm_env='mvd3_reorder_mtypes'
        )


rule touchdetector:
    message:
        "Detect touches between neurites"

    input:
        'circuit.mvd3.reordered',

    output:
        touch(TOUCHES_DIR + '/_SUCCESS')

    log:
        log_path('touchdetector')

    shell:
        bbp_env(
            ['touchdetector'],
            ["env",
                "BGLOCKLESSMPIO_F_TYPE=0x47504653",
             "touchdetector",
                "--mvdFilePath={input}",
                "--morphologyPath={MORPH_RELEASE}/h5v1",
                "--recipePath={BUILDER_RECIPE}",
                "--enableSaveState",
                "--outputFolder={TOUCHES_DIR}",
            ],
            dump_log=True,
            slurm_env='touchdetector'
        )


def run_functionalizer(rule, output_dir, enable_pruning):
    return bbp_env(
        ['functionalizer'],
        ["env",
            "BGLOCKLESSMPIO_F_TYPE=0x47504653",
         "functionalizer",
            "--inMVD-file={input[mvd3]}",
            "--inDetector-file={TOUCHES_DIR}/touches",
            "--recipe-file={BUILDER_RECIPE}",
            "--database={MORPH_RELEASE}/h5v1",
            "--database-file={MORPHDB}",
            "--pruningType=%d" % (1 if enable_pruning else 0),
            "--disableDeltaOutput",
            "--outNCS-file=%s" % os.path.join(output_dir, "a.ncs"),
        ],
        dump_log=True,
        slurm_env=rule
    )


rule s2s:
    message:
        "Convert touches into synapses (S2S)"

    input:
        mvd3 = 'circuit.mvd3',
        touches = TOUCHES_DIR + '/_SUCCESS'

    output:
        expand(NRN_STRUCTURAL_DIR + '/{filename}.0', filename=NRN_FILES)

    log:
        log_path('s2s')

    shell:
        run_functionalizer(
            's2s',
            output_dir=NRN_STRUCTURAL_DIR,
            enable_pruning=False,
        )


rule s2f:
    message:
        "Prune touches and convert them into synapses (S2F)"

    input:
        mvd3 = 'circuit.mvd3',
        touches = TOUCHES_DIR + '/_SUCCESS'

    output:
        expand(NRN_FUNCTIONAL_DIR + '/{filename}.0', filename=NRN_FILES)

    log:
        log_path('s2f')

    shell:
        run_functionalizer(
            's2f',
            output_dir=NRN_FUNCTIONAL_DIR,
            enable_pruning=True,
        )


rule nrn_merge:
    input:
        '{nrn_dir}/{filename}.0'

    output:
        '{nrn_dir}/{filename}'

    wildcard_constraints:
        filename = ".*\.h5$"

    log:
        log_path('nrn_merge_{nrn_dir}_{filename}')

    shell:
        bbp_env(
            ['brainbuilder'],
            ["brainbuilder nrn merge {wildcards.nrn_dir}",
                "--only {wildcards.filename}",
                "--link" if config.get('nrn_merge', "copy") == "link" else "",
            ],
            dump_log=True,
            slurm_env='nrn_merge'
        )


rule touch2parquet:
    message:
        "Convert touches to Parquet format"

    input:
        TOUCHES_DIR + '/_SUCCESS'

    output:
        TOUCHES_DIR + '/parquet/touchesData.0.parquet'

    shell:
        bbp_env(
            ['parquet-converters'],
            ["cd %s" % os.path.join(TOUCHES_DIR, "parquet"),
             "&&",
             "touch2parquetp ../touchesData.*"
            ],
            slurm_env='touch2parquet'
        )


def run_spykfunc(rule, output_dir, enable_pruning):
    return bbp_env(
        ['spykfunc'],
        ["env",
            "SPARK_USER=$(whoami)",
         "sm_run",
            cluster_config.get(rule, {}).get('sm_run', ""),
            "-w %s" % os.path.join(output_dir, 'spykfunc', '.sm_run'),
         "spykfunc",
            "--s2f" if enable_pruning else "--s2s",
            "--output-dir %s" % os.path.join(output_dir, 'spykfunc'),
            "--spark-property spark.master=spark://$(srun sh -c '[ $SLURM_PROCID -eq 0 ] && hostname || true' | tail -n 1):7077",
        ] + [
            "--spark-property %s" % p
                for p in config.get(rule, {}).get('spark_property', [])
        ] + [
            BUILDER_RECIPE,
            os.path.abspath("{input[mvd3]}"),
            MORPH_RELEASE + '/h5v1/',
            os.path.abspath(TOUCHES_DIR + '/parquet/'),
        ],
        dump_log=True,
        slurm_env=rule,
        skip_srun=True
    )


rule spykfunc_s2s:
    message:
        "Convert touches into synapses (S2S)"

    input:
        mvd3 = 'circuit.mvd3',
        touches = TOUCHES_DIR + '/parquet/touchesData.0.parquet'

    output:
        NRN_STRUCTURAL_DIR + '/spykfunc/circuit.parquet/_SUCCESS'

    log:
        log_path('spykfunc_s2s')

    shell:
        run_spykfunc(
            'spykfunc_s2s',
            output_dir=NRN_STRUCTURAL_DIR,
            enable_pruning=False,
        )


rule spykfunc_s2f:
    message:
        "Prune touches and convert them into synapses (S2F)"

    input:
        mvd3 = 'circuit.mvd3',
        touches = TOUCHES_DIR + '/parquet/touchesData.0.parquet'

    output:
        NRN_FUNCTIONAL_DIR + '/spykfunc/circuit.parquet/_SUCCESS'

    log:
        log_path('spykfunc_s2f')

    shell:
        run_spykfunc(
            'spykfunc_s2f',
            output_dir=NRN_FUNCTIONAL_DIR,
            enable_pruning=True
        )


rule parquet2syn2:
    message:
        "Convert synapses from Parquet to SYN2 format"

    input:
        '{nrn_dir}/spykfunc/circuit.parquet/_SUCCESS'

    output:
        '{nrn_dir}/circuit.syn2'

    log:
        log_path('parquet2syn2_{nrn_dir}')

    shell:
        bbp_env(
            ['parquet-converters'],
            ["parquet2syn2p",
                "-o {output}",
                "{wildcards.nrn_dir}/spykfunc/circuit.parquet/*.parquet",
            ],
            dump_log=True,
            slurm_env='parquet2syn2'
        )


rule targetgen_mvd3:
    message:
        "Generate start.target file"

    input:
        'circuit.mvd3'

    output:
        'start.target'

    shell:
        bbp_env(
            ['brainbuilder'],
            ["brainbuilder targets from-mvd3",
                ("--targets %s" % bioname_path(config['targetgen_mvd3']['targets'])
                    if 'targets' in config.get('targetgen_mvd3', {}) else ""),
                ("--allow-empty"
                    if config.get('targetgen_mvd3', {}).get('allow_empty', False) else ""),
                "--output {output}",
                "{input}"
            ],
            slurm_env='targetgen_mvd3'
        )


rule symlink_start_target:
    message:
        "Symlink start.target file from {wildcards.nrn_dir}"

    input:
        'start.target'

    output:
        '{nrn_dir}/start.target',

    shell:
        'cd {wildcards.nrn_dir} && ln -s ../../{input}'


rule mvd3to2:
    message:
        "MVD3 -> MVD2 (if applicable; for backwards compatibility)"

    input:
        'circuit.mvd3'

    output:
        'circuit.mvd2'

    shell:
        bbp_env(
            ['brainbuilder'],
            ["brainbuilder mvd3 to-mvd2",
                "--morph-dir {MORPH_RELEASE}",
                "--output {output}"
            ],
            slurm_env='mvd3to2'
        )


rule spatial_index_segment:
    message:
        "Generate segment spatial index"

    input:
        PRE_FUNCTIONAL

    output:
        SEGMENT_INDEX

    log:
        log_path('spatial_index_segment')

    shell:
        bbp_env(
            ['nix/hpc/flatindexer'],
            [
             "SDKGenerator CircuitConfig segment All SEGMENT",
            ],
            dump_log=True,
            slurm_env='spatial_index_segment'
        )


rule spatial_index_synapse:
    message:
        "Generate synapse spatial index"

    input:
        PRE_FUNCTIONAL,
        NRN_FUNCTIONAL_DATA,

    output:
        NRN_FUNCTIONAL_INDEX

    log:
        log_path('spatial_index_synapse')

    shell:
        bbp_env(
            ['nix/hpc/flatindexer'],
            [
             "SDKGenerator CircuitConfig synapse All {NRN_FUNCTIONAL_DIR}/SYNAPSE",
            ],
            dump_log=True,
            slurm_env='spatial_index_synapse'
        )


rule mvd3_to_sonata:
    message:
        "MVD3 -> SONATA Nodes"

    input:
        'circuit.mvd3'

    output:
        'nodes.sonata'

    shell:
        bbp_env(
            ['brainbuilder'],
            ["brainbuilder mvd3 to-sonata",
                "--output {output}",
                "{input}"
            ],
            slurm_env='mvd3_to_sonata'
        )


rule syn2_to_sonata:
    message:
        "SYN2 -> SONATA Edges"

    input:
        '{nrn_dir}/circuit.syn2'

    output:
        '{nrn_dir}/edges.sonata'

    shell:
        bbp_env(
            ['brainbuilder'],
            ["brainbuilder syn2 to-sonata",
                "--output {output}",
                "{input}"
            ],
            slurm_env='syn2_to_sonata'
        )


rule subcellular:
    message:
        "Assign gene expressions / protein concentrations to cells"

    input:
        'circuit.mvd3'

    output:
        'subcellular.h5'

    shell:
        bbp_env(
            ['brainbuilder'],
            ["brainbuilder subcellular assign",
                "--gene-expressions {config[subcellular][gene_expressions]}",
                "--gene-mapping {config[subcellular][gene_mapping]}",
                "--cell-proteins {config[subcellular][cell_proteins]}",
                "--synapse-proteins {config[subcellular][synapse_proteins]}",
                "--seed {config[transcriptome][seed]}",
                "--output {output}",
                "{input}"
            ],
            slurm_env='subcellular'
        )


rule place_astrocytes:
    message:
        "Assign astrocyte soma positions & radii"

    output:
        'ngv/astrocytes.mvd3'

    log:
        log_path('place_astrocytes')

    shell:
        bbp_env(
            ['brainbuilder'],
            ["brainbuilder astrocytes place",
                "--atlas",
                    ATLAS,
                "--atlas-cache",
                    ATLAS_CACHE_DIR,
                "--density",
                    "{config[place_astrocytes][density]}",
                "--soma-radii",
                    enquote("{config[place_astrocytes][soma_radii]}"),
                "--seed",
                    "{config[place_astrocytes][seed]}",
                "--output",
                    "{output}",
            ],
            dump_log=True,
            slurm_env='place_astrocytes'
        )


rule astrocyte_domains_tesselate:
    message:
        "Tesselate astrocyte domains"

    input:
        'ngv/astrocytes.mvd3'

    output:
        'ngv/astrocyte_domains.h5'

    log:
        log_path('astrocyte_domains_tesselate')

    shell:
        bbp_env(
            ['brainbuilder'],
            ["brainbuilder astrocytes domains tesselate",
                "--atlas",
                    ATLAS,
                "--atlas-cache",
                    ATLAS_CACHE_DIR,
                "--output",
                    "{output}",
                "{input}",
            ],
            dump_log=True,
            slurm_env='astrocyte_domains_tesselate'
        )


rule astrocyte_domains_overlap:
    message:
        "Overlap astrocyte domains"

    input:
        'ngv/astrocyte_domains.h5'

    output:
        'ngv/astrocyte_domains_overlap.h5'

    log:
        log_path('astrocyte_domains_overlap')

    shell:
        bbp_env(
            ['brainbuilder'],
            ["brainbuilder astrocytes domains overlap",
                "--distr",
                    enquote("{config[astrocyte_domains_overlap][overlap]}"),
                "--seed",
                    "{config[astrocyte_domains_overlap][seed]}",
                "--output",
                    "{output}",
                "{input}",
            ],
            dump_log=True,
            slurm_env='astrocyte_domains_overlap'
        )


rule astrocyte_domains_mesh:
    message:
        "Mesh astrocyte domains"

    input:
        'ngv/{filename}.h5'

    output:
        'ngv/{filename}.stl'

    shell:
        bbp_env(
            ['brainbuilder'],
            ["brainbuilder astrocytes domains mesh",
                "--output",
                    "{output}",
                "{input}",
            ],
            slurm_env='astrocyte_domains_mesh'
        )


rule ngv:
    input:
        'ngv/astrocytes.mvd3',
        'ngv/astrocyte_domains.h5',
        'ngv/astrocyte_domains.stl',
        'ngv/astrocyte_domains_overlap.h5',
        'ngv/astrocyte_domains_overlap.stl',
