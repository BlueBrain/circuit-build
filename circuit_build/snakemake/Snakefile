from pathlib import Path

from utils import Config, Context

conf = Config(config=config)
ctx = Context(conf=conf, workflow=workflow, cluster_config=cluster_config)

ctx.check_git_info(ctx.BIONAME)


rule default:
    run:
        logger.warning("Please specify the desired rule(s) from the following list:")
        workflow.list_rules(only_targets=True)


rule circuitconfig_base:
    # needed only by spatial_index_segment
    message:
        "Generate CircuitConfig w/o connectome"
    output:
        "CircuitConfig_base",
    log:
        ctx.log_path("circuitconfig_base"),
    shell:
        ctx.build_circuit_config(nrn_path=".", cell_library_file="circuit.mvd3")


rule circuitconfig_functional:
    message:
        "Generate CircuitConfig for functional circuit"
    input:
        f"sonata/networks/edges/functional/{ctx.EDGE_POPULATION_NAME}/edges.h5",
        f"sonata/networks/nodes/{ctx.NODE_POPULATION_NAME}/nodes.h5",
    output:
        "CircuitConfig",
    log:
        ctx.log_path("circuitconfig_functional"),
    shell:
        ctx.build_circuit_config(
            nrn_path=Path(
                ctx.CIRCUIT_DIR,
                f"sonata/networks/edges/functional/{ctx.EDGE_POPULATION_NAME}/edges.h5",
            ).absolute(),
            cell_library_file=Path(
                ctx.CIRCUIT_DIR, f"sonata/networks/nodes/{ctx.NODE_POPULATION_NAME}/nodes.h5"
            ).absolute(),
        )


rule circuitconfig_structural:
    message:
        "Generate CircuitConfig for structural circuit"
    input:
        f"sonata/networks/edges/structural/{ctx.EDGE_POPULATION_NAME}/edges.h5",
        f"sonata/networks/nodes/{ctx.NODE_POPULATION_NAME}/nodes.h5",
    output:
        "CircuitConfig_struct",
    log:
        ctx.log_path("circuitconfig_structural"),
    shell:
        ctx.build_circuit_config(
            nrn_path=Path(
                ctx.CIRCUIT_DIR,
                f"sonata/networks/edges/structural/{ctx.EDGE_POPULATION_NAME}/edges.h5",
            ).absolute(),
            cell_library_file=Path(
                ctx.CIRCUIT_DIR, f"sonata/networks/nodes/{ctx.NODE_POPULATION_NAME}/nodes.h5"
            ).absolute(),
        )


rule init_cells:
    message:
        "Create an empty cell collection with a correct population name. This collection will be populated further."
    output:
        "circuit.empty.h5",
    log:
        ctx.log_path("init_cells"),
    shell:
        ctx.bbp_env(
            "brainbuilder",
            [
                'echo -n "Using python: " && which python &&',
                'python -c "from voxcell import CellCollection;',
                f"cells = CellCollection('{ctx.NODE_POPULATION_NAME}');",
                "cells.save('{output}');",
                '"',
            ],
        )


rule place_cells:
    message:
        "Generate cell positions; assign me-types"
    input:
        "circuit.empty.h5",
    output:
        "circuit.somata.h5",
    log:
        ctx.log_path("place_cells"),
    shell:
        ctx.bbp_env(
            "brainbuilder",
            [
                "brainbuilder cells place",
                "--input",
                "{input}",
                "--composition",
                ctx.bioname_path("cell_composition.yaml"),
                "--mtype-taxonomy",
                ctx.bioname_path("mtype_taxonomy.tsv"),
                "--atlas",
                ctx.ATLAS,
                "--atlas-cache",
                ctx.ATLAS_CACHE_DIR,
                f"--mini-frequencies {ctx.bioname_path('mini_frequencies.tsv')}"
                if conf.get(["place_cells", "mini_frequencies"], default=False)
                else "",
                ctx.format_if("--region {}", conf.get(["common", "region"])),
                ctx.format_if("--mask {}", conf.get(["common", "mask"])),
                "--soma-placement",
                conf.get(["place_cells", "soma_placement"]),
                "--density-factor",
                conf.get(["place_cells", "density_factor"], default=1.0),
            ]
            + [
                f"--atlas-property {k} {v}"
                for k, v in conf.get(
                    ["place_cells", "atlas_property"], default={"region": "~brain_regions"}
                ).items()
            ]
            + [
                "--append-hemisphere"
                if conf.get(["place_cells", "append_hemisphere"], default=False)
                else "",
                ctx.format_if(
                    "--sort-by {}",
                    value=conf.get(["place_cells", "sort_by"]),
                    func=lambda x: ",".join(x),
                ),
                "--seed",
                conf.get(["place_cells", "seed"]),
                "--output",
                "{output}",
            ],
            slurm_env="place_cells",
        )


rule choose_morphologies:
    message:
        "Choose morphologies using 'placement hints' approach"
    input:
        "circuit.somata.h5",
    output:
        "morphologies.tsv",
    log:
        ctx.log_path("choose_morphologies"),
    shell:
        ctx.bbp_env(
            "placement-algorithm",
            [
                "choose-morphologies",
                "--cells-path",
                "{input}",
                "--atlas",
                ctx.ATLAS,
                "--atlas-cache",
                ctx.ATLAS_CACHE_DIR,
                "--morphdb",
                ctx.MORPHDB,
                "--rules",
                ctx.bioname_path("placement_rules.xml"),
                "--annotations",
                Path(ctx.MORPH_RELEASE, "annotations.json"),
                "--alpha",
                conf.get(["choose_morphologies", "alpha"]),
                "--seed",
                conf.get(["choose_morphologies", "seed"]),
                "--output",
                "{output}",
            ],
            slurm_env="choose_morphologies",
        )


rule assign_morphologies:
    message:
        "Assign morphologies"
    input:
        cells="circuit.somata.h5",
        morph="morphologies.tsv",
    output:
        "circuit.morphologies.h5",
    log:
        ctx.log_path("assign_morphologies"),
    shell:
        ctx.bbp_env(
            "placement-algorithm",
            [
                "assign-morphologies",
                "--cells-path",
                "{input[cells]}",
                "--morph",
                "{input[morph]}",
                "--atlas",
                ctx.ATLAS,
                "--atlas-cache",
                ctx.ATLAS_CACHE_DIR,
                "--max-drop-ratio",
                conf.get(["assign_morphologies", "max_drop_ratio"], default=0.0),
                "--out-cells-path",
                "{output}",
            ],
            slurm_env="assign_morphologies",
        )


rule assign_emodels_per_type:
    message:
        "Assign electrical models"
    input:
        "circuit.morphologies.h5",
    output:
        "circuit.{ext}",
    log:
        ctx.log_path("assign_emodels_per_type_{ext}"),
    wildcard_constraints:
        ext="h5|mvd3",
    shell:
        ctx.bbp_env(
            "brainbuilder",
            [
                "brainbuilder cells assign-emodels",
                "--morphdb",
                ctx.MORPHDB,
                "--output {output}",
                "--seed",
                conf.get(["assign_emodels", "seed"], default=0),
                "{input}",
            ],
            slurm_env="assign_emodels",
        )


rule assign_emodels:
    input:
        expand(["circuit.{ext}"], ext=["h5", "mvd3"]),


rule provide_me_info:
    message:
        "Provide MorphoElectrical info for SONATA Nodes"
    input:
        "circuit.h5",
    output:
        f"sonata/networks/nodes/{ctx.NODE_POPULATION_NAME}/nodes.h5",
    log:
        ctx.log_path("provide_me_info"),
    shell:
        ctx.bbp_env(
            "brainbuilder",
            [
                "brainbuilder sonata provide-me-info",
                ctx.format_if("--mecombo-info {}", ctx.EMODEL_RELEASE_MECOMBO),
                "--model-type biophysical",
                "--output {output}",
                "{input}",
            ],
            slurm_env="sonata_provide_me_info",
        )


rule touchdetector:
    message:
        "Detect touches between neurites"
    input:
        neurons=f"sonata/networks/nodes/{ctx.NODE_POPULATION_NAME}/nodes.h5",
    output:
        touch(ctx.TOUCHES_DIR + "/_SUCCESS"),
    log:
        ctx.log_path("touchdetector"),
    shell:
        ctx.bbp_env(
            "touchdetector",
            [
                "omplace",
                "touchdetector",
                "--output",
                ctx.TOUCHES_DIR,
                "--touchspace",
                conf.get(["touchdetector", "touchspace"], default="axodendritic"),
                "--from {input[neurons]}",
                ctx.NODE_POPULATION_NAME,
                "--to {input[neurons]}",
                ctx.NODE_POPULATION_NAME,
                ctx.BUILDER_RECIPE,
                f"{ctx.MORPH_RELEASE}/h5v1",
            ],
            slurm_env="touchdetector",
        )


rule touch2parquet:
    message:
        "Convert touches to Parquet format"
    input:
        ctx.TOUCHES_DIR + "/_SUCCESS",
    output:
        directory(ctx.TOUCHES_DIR + "/parquet"),
    log:
        ctx.log_path("touch2parquet"),
    shell:
        "mkdir -p {output} && " + ctx.bbp_env(
            "parquet-converters",
            ["cd {output}", "&&", "touch2parquet ../touchesData.*"],
            slurm_env="touch2parquet",
        )


rule spykfunc_s2s:
    message:
        "Convert touches into synapses (S2S)"
    input:
        neurons=f"sonata/networks/nodes/{ctx.NODE_POPULATION_NAME}/nodes.h5",
        touches=ctx.TOUCHES_DIR + "/parquet",
    output:
        ctx.CONNECTOME_STRUCTURAL_DIR + "/spykfunc/circuit.parquet/_SUCCESS",
    log:
        ctx.log_path("spykfunc_s2s"),
    shell:
        ctx.run_spykfunc("spykfunc_s2s", connectome_dir=ctx.CONNECTOME_STRUCTURAL_DIR)


rule spykfunc_s2f:
    message:
        "Prune touches and convert them into synapses (S2F)"
    input:
        neurons=f"sonata/networks/nodes/{ctx.NODE_POPULATION_NAME}/nodes.h5",
        touches=ctx.TOUCHES_DIR + "/parquet",
    output:
        ctx.CONNECTOME_FUNCTIONAL_DIR + "/spykfunc/circuit.parquet/_SUCCESS",
    log:
        ctx.log_path("spykfunc_s2f"),
    shell:
        ctx.run_spykfunc("spykfunc_s2f", connectome_dir=ctx.CONNECTOME_FUNCTIONAL_DIR)


rule targetgen:
    message:
        "Generate start.target file"
    input:
        "circuit.h5",
    output:
        "start.target",
    log:
        ctx.log_path("targetgen"),
    shell:
        ctx.bbp_env(
            "brainbuilder",
            [
                "brainbuilder targets from-input",
                f"--targets {ctx.bioname_path(ctx.get_targetgen_config('targets'))}"
                if ctx.get_targetgen_config("targets", False)
                else "",
                "--allow-empty" if ctx.get_targetgen_config("allow_empty", False) else "",
                "--atlas",
                ctx.ATLAS,
                "--atlas-cache",
                ctx.ATLAS_CACHE_DIR,
                "--output {output}",
                "{input}",
            ],
            slurm_env="targetgen_mvd3",
        )


rule node_sets:
    message:
        "Generate SONATA node sets"
    input:
        f"sonata/networks/nodes/{ctx.NODE_POPULATION_NAME}/nodes.h5",
    output:
        f"sonata/{ctx.NODESETS_FILE}",
    log:
        ctx.log_path("node_sets"),
    shell:
        ctx.bbp_env(
            "brainbuilder",
            [
                "brainbuilder targets node-sets",
                f"--targets {ctx.bioname_path(ctx.get_targetgen_config('targets'))}"
                if ctx.get_targetgen_config("targets", False)
                else "",
                "--allow-empty" if ctx.get_targetgen_config("allow_empty", False) else "",
                "--population",
                ctx.NODE_POPULATION_NAME,
                "--atlas",
                ctx.ATLAS,
                "--atlas-cache",
                ctx.ATLAS_CACHE_DIR,
                "--output {output}",
                "{input}",
            ],
        )


rule spatial_index_segment:
    message:
        "Generate segment spatial index"
    input:
        "CircuitConfig_base",
        "circuit.mvd3",
        "start.target",
    output:
        ctx.spatial_index_files("SEGMENT"),
    log:
        ctx.log_path("spatial_index_segment"),
    shell:
        ctx.bbp_env(
            "flatindexer",
            [
                "SDKGenerator CircuitConfig_base segment All SEGMENT",
            ],
            slurm_env="spatial_index_segment",
        )


rule parquet_to_sonata:
    message:
        "Convert synapses from Parquet to SYN2 format"
    input:
        parquet="connectome/{connectome_dir}/spykfunc/circuit.parquet/_SUCCESS",
        cells=f"sonata/networks/nodes/{ctx.NODE_POPULATION_NAME}/nodes.h5",
    output:
        "sonata/networks/edges/{connectome_dir}/" + ctx.EDGE_POPULATION_NAME + "/edges.h5",
    log:
        ctx.log_path("parquet_to_sonata_{connectome_dir}"),
    shell:
        ctx.bbp_env(
            "parquet-converters",
            [
                "parquet2hdf5",
                "--format SONATA",
                "--population",
                ctx.EDGE_POPULATION_NAME,
                "--from {input[cells]}",
                ctx.NODE_POPULATION_NAME,
                "--to {input[cells]}",
                ctx.NODE_POPULATION_NAME,
                "-o {output}",
                "connectome/{wildcards.connectome_dir}/spykfunc/circuit.parquet/*.parquet",
            ],
            slurm_env="parquet2syn2",
        )


rule subcellular:
    message:
        "Assign gene expressions / protein concentrations to cells"
    input:
        file="circuit.h5",
        directory="subcellular",
    output:
        "subcellular.h5",
    log:
        ctx.log_path("subcellular"),
    shell:
        ctx.bbp_env(
            "brainbuilder",
            [
                "brainbuilder subcellular assign",
                "{input[file]}",
                "--subcellular-dir {input[directory]}",
                "--transcriptome {config[subcellular][transcriptome]}",
                "--mtype-taxonomy {config[subcellular][mtype_taxonomy]}",
                "--cell-proteins {config[subcellular][cell_proteins]}",
                "--synapse-proteins {config[subcellular][synapse_proteins]}",
                "--seed {config[subcellular][seed]}",
                "--output {output}",
            ],
            slurm_env="subcellular",
        )


rule circuitconfig_sonata:
    message:
        "Generate SONATA network config"
    output:
        "sonata/circuit_config.json",
    log:
        ctx.log_path("circuitconfig_sonata"),
    shell:
        ctx.write_network_config("functional")


rule circuitconfig_struct_sonata:
    message:
        "Generate SONATA network config (structural)"
    output:
        "sonata/struct_circuit_config.json",
    log:
        ctx.log_path("circuitconfig_struct_sonata"),
    shell:
        ctx.write_network_config("structural")


rule functional:
    # Note: creating both BlueConfig & circuit_config.json until we're fully transitioned to SONATA
    input:
        "sonata/circuit_config.json",
        f"sonata/networks/nodes/{ctx.NODE_POPULATION_NAME}/nodes.h5",
        f"sonata/{ctx.NODESETS_FILE}",
        f"sonata/networks/edges/functional/{ctx.EDGE_POPULATION_NAME}/edges.h5",
        # for backwards compatibility
        "CircuitConfig",
        "start.target",


rule structural:
    input:
        "sonata/struct_circuit_config.json",
        f"sonata/{ctx.NODESETS_FILE}",
        f"sonata/networks/nodes/{ctx.NODE_POPULATION_NAME}/nodes.h5",
        f"sonata/networks/edges/structural/{ctx.EDGE_POPULATION_NAME}/edges.h5",
        "CircuitConfig_struct",
        "start.target",
